# 5. 연관관계 매핑 기초
- 목표: 객체의 참조와 테이블의 외래 키를 매핑하는 것

## 5.1 단방향 연관관계
- 회원과 팀의 관계 가정
  - 회원과 팀이 있다.
  - 회원은 하나의 팀에만 소속될 수 있다.
  - 회원과 팀은 다대일 관계이다.
- 객체 연관관계
  - 회원 객체는 `Member.team` 필드로 팀 객체와 연관관계를 맺음
  - 회원 객체와 팀 객체는 단방향 관계 (N:1)
  - member -> team 조회는 member.getTeam()으로 가능
    - 반대 방향인 team -> member 접근 불가
- 테이블 연관관계
  - 회원 테이블은 `TEAM_ID` 외래 키로 팀 테이블과 연관관계를 맺음
  - 회원 테이블과 팀 테이블은 양방향 관계
  - `TEAM_ID` 외래 키 하나로 MEMBER JOIN TEAM, TEAM JOIN MEMBER 둘 다 가능
- 객체 연관관계 vs 테이블 연관관계
  - 참조를 사용하는 객체의 연관관계는 항상 단방향
    - 객체간에 양방향 연관관계를 만들기 위해서는 반대쪽에도 필드를 추가해서 참조를 보관해야 함
    - But, 정확히는 양방향 관계가 아니라 서로 다른 단방향 관계 2개
  - 외래 키를 사용하는 테이블의 연관관계는 양방향

<br>

### 5.1.1 순수한 객체 연관관계
- 객체 그래프 탐색: 객체는 참조를 사용해서 연관관계 탐색이 가능

### 5.1.2 테이블 연관관계
- 조인: 데이터베이스는 외래 키를 사용해서 연관관계 탐색이 가능

### 5.1.3 객체 관계 매핑
- 객체 연관관계: 회원 객체의 `Member.team` 필드 사용
- 테이블 연관관계: 회원 테이블의 `MEMBER.TEAM_ID` 외래 키 컬럼 사용
- 매핑한 회원 엔티티 일부
  ```java
  @Entity
  public class Member {
      
      ...

      // 연관관계 매핑
      @ManyToOne
      @JoinColumn(name="TEAM_ID")
      private Team team;

  }
  ```
- 매핑한 팀 엔티티 일부
  ```java
  @Entity
  public class Team {
      
      @Id
      @Column(name="TEAM_ID")
      private String id;
      
      private String name;

      ...
  }
  ```
  - `@ManyToOne` : 다대일(N:1) 관계라는 매핑 정보
    - 위의 회원과 팀은 다대일 관계
    - 속성
      - `optional`: 기본값 true, false 설정 시 연관된 데이터가 항상 존재해야 함
      - `fetch`: 글로벌 페치 전략 설정
        - `@ManyToOne=FetchType.EAGER`
        - `@OneToMany=FetchType.LAZY`
      - `cascade`: 영속성 전이 기능 사용
      - `targetEntity`: 연관된 엔티티의 타입 정보 설정, 거의 사용하지 않는 기능
  - `@JoinColumn` : 외래 키를 매핑할 때 사용
    - `name` 속성에는 매핑할 외래 키 이름 지정, 위에서는 `TEAM_ID`
    - 이 어노테이션은 생략 가능
    - 생략할 경우 외래 키를 찾을 때 기본 전략 사용
      - 기본 전략: `필드명` + `_` + `참조하는 테이블의 컬럼명`

<br>
<br>

## 5.2 연관관계 사용

### 5.2.1 저장
- 연관관계를 매핑한 엔티티를 저장
  ```java
  member1.setTeam(team1);   // 회원->팀 참조
  em.persist(member1);      // 저장
  ```
  - 주의) JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 함

### 5.2.2 조회
- 객체 그래프 탐색(객체 연관관계를 사용한 조회)
  - `member.getTeam()`
- 객체지향 쿼리 사용(JPQL)
  - 연관된 테이블을 조인해서 검색조건 사용
  - `select m from Member m join m.team t where t.name=:teamName`
    - 팀1에 소속된 모든 회원 조회
    - `:`로 시작하는 것은 파라미터를 바인딩받는 문법

### 5.2.3 수정
- 수정은 별도의 메소드가 없음
- 엔티티의 값을 변경해두면 -> 트랜잭션 커밋 시 플러시가 일어나면서 변경 감지 기능 작동 -> 변경사항을 DB에 자동 반영
- 연관관계 수정할 때도 동일

### 5.2.4 연관관계 제거
- 회원1을 팀에 소속하지 않도록 변경
  ```java
  member1.setTeam(null);
  ```

### 5.2.5 연관된 엔티티 삭제
- 연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거한 후 삭제해야 함
- 그렇지 않으면 외래 키 제약조건으로 인해 DB에서 오류 발생
  ```java
  member1.setTeam(null);    // 회원1 연관관계 제거
  em.remove(team);          // 팀 삭제
  ```

<br>
<br>

## 5.3 양방향 연관관계
- 객체 연관관계는 2개
  - 회원 -> 팀 (단방향): `Member.team`
  - 팀 -> 회원 (단방향): `Team.members` List 컬렉션 추가
- 테이블 연관관계는 1개
  - 회원 <-> 팀 (양방향)

### 5.3.1 양방향 연관관계 매핑
- 매핑한 회원 엔티티는 동일
- 매핑한 팀 엔티티 일부
  ```java
  @Entity
  public class Team {

      @Id
      @Column(name="TEAM_ID")
      private String id;
      
      private String name;

      // 추가
      @OneToMany(mappedBy = "team")
      private List<Member> members = new ArrayList<Member>();

      ...
  }
  ```
  - `@OneToMany`: 일대다 관계를 매핑하기 위해 사용
    - 팀과 회원은 일대다 관계
    - `mappedBy` 속성: 양방향 매핑일 때 사용, 반대쪽 매핑의 필드 이름을 값으로 지정

### 5.3.2 일대다 컬렉션 조회
- 팀에서 회원 컬렉션으로 객체 그래프 탐색
  ```java
  List<Member> members = team.getMembers();    // 팀->회원
  ```

<br>
<br>

## 5.4 연관관계의 주인
- 테이블은 외래 키 하나로 두 테이블의 연관관계 관리
- 엔티티를 단방향으로 매핑하면 참조를 하나만 사용하므로, 해당 참조로 외래 키 관리
- 엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나
- 둘 사이에 차이가 발생
- JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래 키를 관리해야 함 -> **연관관계의 주인**

### 5.4.1 양방향 매핑의 규칙: 연관관계의 주인
- 객체의 두 연관관계 중 하나를 연관관계의 주인으로 지정
- 연관관계의 주인만이 DB 연관관계에 매핑되고, 외래 키를 관리(등록, 수정, 삭제) 가능 
  - 주인이 아닌 쪽은 읽기만 가능
- 주인은 `mappedBy` 속성 사용하지 않음
  - 주인이 아니면 `mappedBy` 속성의 값으로 연관관계의 주인 지정

### 5.4.2 연관관계의 주인은 외래 키가 있는 곳
- 연관관계의 주인을 정한다는 것은 사실 외래 키 관리자를 선택하는 것
- 연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야 함
- 여기서는 회원 테이블이 외래 키를 가지므로 `Member.team`이 연관관계의 주인
  - 주인이 아닌 `Team.members`에는 `mappedBy` 속성의 값으로 연관관계의 주인인 `team` 지정

<br>
<br>

## 5.5 양방향 연관관계 저장
- 연관관계의 주인이 아닌 곳에 입력된 값은 외래 키에 영향을 주지 않음
  ```java
  team.getMembers().add(member);    // 무시(연관관계의 주인이 아님)
  member.setTeam(team);     // 연관관계 설정(연관관계의 주인)
  ```

<br>
<br>

## 5.6 양방향 연관관계의 주의점
- 가장 흔히 하는 실수는 연관관계의 주인에는 값을 입력하지 않고, 주인이 아닌 곳에만 값을 입력하는 것
- 양방향 매핑시에는 무한 루프를 조심해야 함

### 5.6.1 순수한 객체까지 고려한 양방향 연관관계
- 객체 관점에서는 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전함
  - 양쪽 모두 입력하지 않으면, JPA를 사용하지 않는 순수 객체 상태에서 문제 발생 가능
- 결론: 객체의 양방향 연관관계는 주인이 아닌 곳까지 양쪽 모두 관계를 맺어주자

### 5.6.2 연관관계 편의 메소드
```java
public class Member {
      
    private Team team;
      
    public void setTeam(Team team) {

        // 기존 팀과의 관계 제거
        if (this.team != null) {
            this.team.getMembers().remove(this);
        }    
        this.team = team;
        team.getMembers().add(this);
    }
    ...
}
```
- 각각 호출하다 보면 둘 중 하나만 호출하는 실수로 양방향이 깨질 수 있음
- 두 코드가 하나인 것처럼 묶어서 사용하는 것이 안전

<br>
<br>

## 5.7 정리
- 단방향 매핑만으로 테이블과 객체의 연관관계 매핑은 이미 완료되었다. 
- 단방향을 양방향으로 만들면 반대방향으로 객체 그래프 탐색 기능이 추가된다.  
- 양방향 연관관계를 매핑하려면 객체에서 양쪽 방향을 모두 관리해야 한다.
- 연관관계의 주인을 정하는 기준에 대하여
  - 연관관계의 주인은 외래 키의 위치와 관련해서 정해야지 비즈니스 중요도로 접근하면 안된다. 

<br>
<br>

## Reference
- [자바 ORM 표준 JPA 프로그래밍](http://www.yes24.com/Product/Goods/19040233) - 김영한 저. 에이콘출판사. 2015
