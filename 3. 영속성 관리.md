# 3. 영속성 관리
- JPA에서 가장 중요한 2가지
  - 객체와 관계형 데이터베이스 매핑하기
  - 영속성 컨텍스트

<br>

## 3.1 엔티티 매니저 팩토리와 엔티티 매니저
- `EntityManagerFactory`는 일반적으로 한 개만 만들어서 애플리케이션 전체에서 공유
  - 여러 스레드가 동시에 접근해도 안전 -> 서로 다른 스레드 간 공유 가능
- `EntityManager`는 필요할 때마다 EntityManagerFactory에서 생성
  - 여러 스레드가 동시에 접근하면 동시성 문제가 발생 -> 스레드 간에 절대 공유 불가
  - 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않음
    - 보통 트랜잭션을 시작할 때 커넥션 획득

<br>
<br>

## 3.2 영속성 컨텍스트(persistence context)란?
- 엔티티를 영구 저장하는 환경
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근
  ```java
  EntityManager.persist(entity);
  ```
  - 하나의 엔티티 매니저를 생성할 때, 하나의 영속성 컨텍스트가 만들어진다고 생각 가능

<br>
<br>

## 3.3 엔티티와 생명주기
- 비영속 (new/transient): 영속성 컨텍스트와 전혀 관계가 없는 **새로운** 상태 
  - 아직 저장하지 않고, 순수하게 엔티티 객체를 생성한 상태
- 영속 (managed): 영속성 컨텍스트에 **관리**되는(저장된) 상태 
  ```
  em.persist(member);
  ```
- 준영속 (detached): 영속성 컨텍스트에 저장되었다가 **분리**된 상태 
  ```
  em.detach(member);
  ```
- 삭제 (removed): **삭제**된 상태
  ```
  em.remove(member);
  ```

<br>
<br>

## 3.4 영속성 컨텍스트의 특징
- 영속성 컨텍스트와 식별자 값: 영속 상태는 식별자 값(@Id로 테이블의 기본 키와 매핑한 값)이 반드시 있어야 함
- 영속성 컨텍스트와 데이터베이스 저장: JPA는 보통 트랜잭션을 커밋하는 순간, 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영 -> flush
- 영속성 컨텍스트의 장점
  1. 1차 캐시
  2. 동일성(identity) 보장
  3. 트랜잭션을 지원하는 쓰기 지연(Transactional write-behind)
  4. 변경 감지 (Dirty Checking)
  5. 지연 로딩 (Lazy Loading)

<br>

### 3.4.1 엔티티 조회
- 1차 캐시: 영속성 컨텍스트가 내부에 가지고 있는 캐시
  - 영속 상태의 엔티티는 모두 이곳에 저장
  - 내부에 Map이 하나 있고, `@Id`를 `키`, `Entity`를 `값`으로 저장
- 1차 캐시에서 조회
  - `em.find()`를 호출하면 우선 1차 캐시에서 식별자 값으로 엔티티를 찾음
    - 찾는 엔티티 존재 시, 데이터베이스를 조회하지 않고 1차 캐시에서 엔티티 조회
- 데이터베이스에서 조회
  - `em.find()`를 호출했는데 1차 캐시에 엔티티가 없을 경우
  - 엔티티 매니저는 데이터베이스를 조회해서 엔티티 생성
  - 1차 캐시에 저장한 후, 영속 상태의 엔티티 반환
- 영속 엔티티의 동일성 보장
  ```java
  Member a = em.find(Member.class, "member1"); 
  Member b = em.find(Member.class, "member1");

  System.out.println(a == b); // 동일성 비교 true
  ```
- 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장

<br>

### 3.4.2 엔티티 등록
- 트랜잭션을 지원하는 쓰기 지연
  - 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 INSERT SQL을 모아둠 (데이터베이스에 저장X)
  - 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 한번에 보냄

<br>

### 3.4.3 엔티티 수정
- 변경 감지 (Dirty Checking): 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능
  - 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용됨
- JPA의 기본 전략은 엔티티의 모든 필드를 업데이트
- 스냅샷: JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는 것
1. 트랜잭션 커밋 시, 엔티티 매니저 내부에서 `flush()` 호출
2. 엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾음
3. 변경된 엔티티가 있으면, 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보냄
4. 쓰기 지연 저장소의 SQL을 데이터베이스에 보냄
5. 데이터베이스 트랜잭션을 커밋함

<br>
<br>

## 3.5 플러시(flush)
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것
- 플러시 실행 과정
  1. 변경 감지
  2. 수정된 엔티티의 수정 쿼리를 쓰기 지연 SQL 저장소에 등록 
  3. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송 (등록, 수정, 삭제 쿼리)
- 영속성 컨텍스트를 플러시하는 방법
  1. `em.flush()` - 직접 호출
  2. 트랜잭션 커밋 - 플러시가 자동 호출
  3. JPQL 쿼리 실행 - 플러시가 자동 호출
- 플러시 모드 옵션
  - `FlushModeType.AUTO`: 커밋이나 쿼리를 실행할 때 플러시 (기본값) 
  - `FlushModeType.COMMIT`: 커밋할 때만 플러시
- 주의) 플러시는 영속성 컨텍스트를 비우지 않음
  - 변경 내용을 데이터베이스에 동기화하는 것

<br>
<br>

## 3.6 준영속
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것
  - 영속 -> 준영속
  - 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능 사용 불가능
- 준영속 상태로 만드는 방법
  - `em.detach(entity)`: 특정 엔티티만 준영속 상태로 전환
  - `em.clear()`: 영속성 컨텍스트를 완전히 초기화
  - `em.close()`: 영속성 컨텍스트를 종료

<br>
<br>

## Reference
- [자바 ORM 표준 JPA 프로그래밍](http://www.yes24.com/Product/Goods/19040233) - 김영한 저. 에이콘출판사. 2015
