# 1. JPA 소개

## 1.1 SQL을 직접 다룰 때 발생하는 문제점

<br>

### 1.1.1 반복, 반복 그리고 반복
- 객체를 데이터베이스에 직접 저장하거나 조회할 수 없음
  - 데이터베이스는 객체 구조와 다른 데이터 중심의 구조를 가지므로
- 개발자가 객체지향 애플리케이션과 데이터베이스 중간에서 변환 작업을 직접 해주어야 함 (SQL과 JDBC API 사용)
- 객체를 DB에 CRUD 할 때마다 많은 SQL과 JDBC API를 코드로 작성해야 한다는 문제점 존재
  - 예시) 회원 객체를 조회하는 기능 개발
    1. 회원 조회용 SQL 작성
    2. JDBC API를 사용해서 SQL 실행
    3. 조회 결과를 Member 객체로 매핑 

<br>

### 1.1.2 SQL에 의존적인 개발
- 애플리케이션에서 SQL을 직접 다룰 때 발생하는 문제점
  - 진정한 의미의 계층 분할이 어려움
    - 물리적으로는 SQL과 JDBC API를 데이터 접근 계층에 숨겼을지 몰라도, 논리적으로는 엔티티와 강한 의존관계를 가짐
  - 엔티티를 신뢰할 수 없음
    - DAO를 열어서 어떤 SQL이 실행되고, 어떤 객체들이 함께 조회되는지 하나하나 확인 필요
  - SQL에 의존적인 개발을 피하기 어려움
    - 회원 객체에 필드를 하나 추가할 때도 DAO의 CRUD 코드와 SQL 대부분을 변경해야 하는 문제 발생 

<br>

### 1.1.3 JPA와 문제 해결
- JPA가 제공하는 API를 사용하면, JPA가 적절한 SQL을 생성해서 데이터베이스에 전달
  - 개발자가 직접 SQL 작성할 필요 없음
- JPA가 제공하는 CRUD API
  - 저장: `jpa.persist(member);`
    - JPA가 객체와 매핑정보를 보고 적절한 INSERT SQL 생성해서 DB에 전달 
  - 조회: `Member member = jpa.find(Member.class, memberID);`
    - 적절한 SELECT SQL 생성해서 전달 
  - 수정: `member.setName("이름변경");`
    - 객체를 조회하여 값을 변경하면, 트랜잭션을 커밋할 때 적절한 UPDATE SQL이 DB에 전달 
  - 연관된 객체 조회: `Team team = member.getTeam();`
    - 연관된 객체를 사용하는 시점에 적절한 SELECT SQL 실행 

<br>
<br>

## 1.2 패러다임의 불일치
- 객체와 관계형 데이터베이스의 패러다임 불일치 문제
  - 각각 지향하는 목적이 서로 다르므로 기능과 표현 방법도 다름
  - 객체 구조를 테이블 구조에 저장하는데 한계가 있음
  - OOP: 추상화, 캡슐화, 정보은닉, 상속, 다형성 등 시스템 복잡성을 제어하는 다양한 장치들 제공
  - RDB: 데이터 중심으로 구조화되어 있고, 집합적인 사고 요구
    - 객체지향에서의 추상화, 상속, 다형성 등의 개념이 존재하지 않음
- 패러다임 불일치 문제를 개발자가 중간에서 해결하려면 많은 시간과 코드 필요
  - JPA를 통한 해결책

<br>

### 1.2.1 상속
- 객체는 상속 기능을 가짐
- DB는 상속 기능이 없음
  - 슈퍼타입 서브타입 관계를 사용해 객체 상속과 유사한 형태로 테이블 설계는 가능
  - JDBC API 사용 시, 자식 타입에 따라 DTYPE 지정 및 많은 SQL과 코드 작성 필요
- JPA와 상속
  - 개발자가 객체를 자바 컬렉션에 저장하듯 JPA에 저장, JPA가 상속 관련 패러다임 불일치 문제 해결
  - 예시) `jpa.persist(album)`
    - 알맞은 SQL 실행하여 객체를 ITEM, ALBUM 두 테이블에 나누어 저장
  - 예시) `Album album = jpa.find(Album.class, albumId)` 
    - ITEM, ALBUM 두 테이블을 조인해서 조회하고 알맞은 결과 반환 

<br>

### 1.2.2 연관관계
- 객체: 참조 사용, 참조에 접근해서 연관된 객체 조회, 참조가 있는 방향으로만 조회 가능(반대 방향 불가능)
- 테이블: 외래 키 사용, 조인을 이용해서 연관된 테이블 조회, 외래 키 하나로 양방향 조회 가능
- 객체를 테이블에 맞추어 모델링하거나, 객체지향 모델링을 하는 경우 모두 비효율적
- JPA가 연관관계 관련 패러다임 불일치 문제 해결
  - 객체의 참조와 외래 키 사이의 변환을 적절한 SQL을 생성해서 처리해줌

<br>

### 1.2.3 객체 그래프 탐색
- 여러 개의 객체가 연관관계를 가지고 있는 경우
  - SQL을 직접 다루면, 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지가 정해짐
  - DAO를 열어서 SQL을 직접 확인하지 않으면, 어느 방향까지 그래프 탐색이 가능한지 알 수 없음
  - -> 엔티티가 SQL에 논리적으로 종속된 것
- JPA를 사용하면 객체 그래프를 마음껏 탐색 가능
  - JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행하는 지연 로딩을 지원 
    - 지연 로딩: 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미루는 것 
    - 즉시 로딩: JOIN SQL로 한번에 연관된 객체까지 미리 조회하는 것
  - 지연 로딩 / 즉시 로딩 여부는 간단한 설정으로 정의 가능

<br>

### 1.2.4 비교
- 테이블의 로우(row)를 구분하는 방법과 객체를 구분하는 방법에는 차이가 있음
  - 테이블: 기본 키의 값으로 구분
  - 객체
    - 동일성(identity) 비교: 객체 인스턴스의 주소 값 비교 (==)
    - 동등성(equality) 비교: 객체 내부의 값 비교 (equals())
- 데이터베이스의 같은 로우를 두 번 조회했는데, 객체의 동일성 비교 시 false 반환
  - 같은 데이터베이스 로우지만, 객체에서는 다른 인스턴스이기 때문
- JPA는 **같은 트랜잭션일 때** 같은 객체가 조회되는 것을 보장함

<br>
<br>

## 1.3 JPA란 무엇인가?

### 1.3.1 JPA 소개
- JPA(Java Persistence API): 자바 진영의 ORM 기술에 대한 API 표준 명세
  - 애플리케이션과 JDBC 사이에서 동작
  - 인터페이스의 모음으로, JPA를 사용하려면 이를 구현한 ORM 프레임워크를 선택해야 함
- ORM(Object-Relational Mapping): 객체와 관계형 데이터베이스를 매핑한다는 뜻
  - ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결
  - 개발자가 RDB를 사용해도 객체지향 애플리케이션 개발에 집중 가능하도록 함
  - JPA를 구현한 ORM 프레임워크는 하이버네이트, EclipseLink, DataNucleus
  - 자바 진영에서는 하이버네이트 프레임워크가 가장 대중적

<br>

### 1.3.2 왜 JPA를 사용해야 하는가?
- 생산성
  - JPA에게 자바 컬렉션에 객체를 저장하듯이 전달하면, SQL 작성과 JDBC API를 사용하는 반복적인 일은 대신 처리해줌
  - DDL 문(ex. `CREATE TABLE`)을 자동으로 생성해주는 기능도 제공
- 유지보수
  - 필드를 추가하거나 삭제할 때 수정해야 할 코드가 감소함
    - 기존에는 필드 변경 시 개발자가 모든 SQL, JDBC API 코드 수정 필요
    - JPA의 경우, 필드만 추가하면 SQL은 JPA가 대신 처리
- 패러다임의 불일치 해결
  - 상속, 연관관계, 객체 그래프 탐색, 비교하기 등의 패러다임의 불일치 문제를 해결
- 성능
  - 애플리케이션과 DB 사이에서 다양한 성능 최적화 기회를 제공
  - 예시) 같은 트랜잭션 안에서는 같은 엔티티를 반환해서 약간의 조회 성능 향상
- 데이터 접근 추상화와 벤더 독립성
  - 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 함
    - 애플리케이션과 DB 사이에 추상화된 데이터 접근 계층을 제공
  - H2, 오라클, MySQL 등 데이터베이스 변경이 간단함
- 표준
  - 표준을 사용하면 다른 구현 기술로 쉽게 변경 가능

<br>
<br>

## Reference
- [자바 ORM 표준 JPA 프로그래밍](http://www.yes24.com/Product/Goods/19040233) - 김영한 저. 에이콘출판사. 2015
